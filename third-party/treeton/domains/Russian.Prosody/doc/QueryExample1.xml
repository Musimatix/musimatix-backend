<?xml version="1.0" encoding="UTF-8"?>
<Document xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://starling.rinet.ru/treeton/query" xsi:schemaLocation="http://starling.rinet.ru/treeton/query http://starling.rinet.ru/treeton/query/QuerySchema.xsd">
  <!--
   Общая идея такая:

   Пользователь через Web делает запрос. Все летит к apache-у. Apache пускает скрипты, например,
   php. В этих скриптах формируется сначала xml типа вот этого. Этот xml-летит к серверу-хранилища.
   Сервер ищет в хранилище все тринотации, удовлетворяющие запросу (соответствующие блоку
   where). Причем он ищет внутри модели model, только в тех множествах тринотаций, URI которых
   соответствуют регэкспу storageURIPattern и только в тех документах, URI которых соответствуют
   регэкспу documentURIPattern.
     В данном случае он будет искать тринотации у которых либо часть речи - существительное,
   падеж - номинатив или аккузатив, а исходная форма - не "день", либо часть речи - не частица,
   а форма, употребленная в тексте - "еще". Язык шаблонов, означивающих наборы атрибутов, который
   я здесь использую, упоминается в treeton.ppt.
     После этого сервер отсылает то, что требуется в блоках select, обратно в php в виде таблицы,
   поля которой через запятую специфицируются в теле блока select. До первой точки пишется
   название binding-а, т.е. с ссылка на тринотацию, которая сопоставляется с шаблоном.

   После первой точки пишется название поля. Я пока придумал 5 основных, их и привел в примере:

   Document.URI - URI документа, в котором находится тринотация
   Storage.URI - URI множества тринотаций, которому принадлежит тринотация
   URI - URI самой тринотации
   start - стартовый оффсет тринотации
   end - конечный оффсет тринотации

   Получив эти данные, php сможет повторно обращаться к серверу уже не с поисковыми запросами,
   а с различными запросами на экспорт. Например, "выгрузи мне xml из множества тринотаций
   с таким-то URI" или "выдай мне текст, соответствующий таким-то оффсетам" и т.п. Это все
   надо будет, конечно, более конкретно продумывать при разработке GUI.
  -->
  <query model="Common.Russian.Prosody">
    <where>
      <trn binding="A">
        <attrs>Verse: form="IV"</attrs>
      </trn>
    </where>
    <select>A.DocumentURI, A.StorageURI, A.URI, A.start, A.end</select>
    <order>A.DocumentURI, A.StorageURI, A.start</order>
  </query>
</Document>

<?xml version="1.0" encoding="UTF-8"?><Document xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://starling.rinet.ru/treeton/query" xsi:schemaLocation="http://starling.rinet.ru/treeton/query http://starling.rinet.ru/treeton/query/QuerySchema.xsd"><query model="Common.Russian.Prosody"><where><trn binding="A"><attrs>Verse: form="IV"</attrs></trn></where><select>A.DocumentURI, A.StorageURI, A.URI, A.start, A.end</select><order>A.DocumentURI, A.StorageURI, A.start</order></query></Document>
<?xml version="1.0" encoding="UTF-8"?><Document xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://starling.rinet.ru/treeton/query" xsi:schemaLocation="http://starling.rinet.ru/treeton/query http://starling.rinet.ru/treeton/query/QuerySchema.xsd"><query model="Common.Russian.Prosody"><where><trn binding="A" URI="[56141]"/><trn binding="B"><attrs>Fragment</attrs></trn><condition>B overlaps A</condition></where><select>B.URI, B.start, B.end</select><order>B.start</order></query></Document>